package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.absyn.Expression;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    // Apparently there is a cup bug that causes expected_token_ids() to return incorrect results on first call
    // This is why this call is inserted.
    this.expected_token_ids();

    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right),
            this.symbl_name_from_id(currentToken.sym),
            this.expected_token_ids().stream().map(this::symbl_name_from_id).toList());
  }

  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }

  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords





terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals




/* Non-terminals

 statement_list::= /* epsilon  | statement_list statement;
 statement::= assign_statement;
  assign_statement::= IDENT ASGN expression SEMIC;
  expression::=  expression PLUS term | expression MINUS term | term;
  term::= term STAR factor | term SLASH factor | factor;
  factor::=IDENT | INTLIT;

 */
 // Commentaire
non terminal Program program;
non terminal List<GlobalDefinition> globaleDefintionList;
non terminal GlobalDefinition globaleDefinition ;

non terminal List<Statement> statement_list;
non terminal Statement statement;

non terminal Statement assign_statement;
non terminal Expression expression;
non terminal Expression term;

non terminal Expression factor;
non terminal CompoundStatement compound_statement ;
//non terminal Expression operatoren ;

// Typenvereinbarung
non terminal TypeDefinition type ;
non terminal TypeDefinition typeDefinition;

// while Schleife
//non terminal WhileStatement while;

non terminal WhileStatement whileStatement ;


// if Schleife
non terminal Expression array_expression;

// proceduren
non terminal ProcedureDefinition procedure ;
non terminal IfStatement ifStatement ;
non terminal Expression conditional_expression ;
non terminal List<ParameterDefinition> parameterList ; // parameterListe
non terminal List<ParameterDefinition> nonEmptyParameterList ; // Nicht leere ParamterListe
non terminal List<ParameterDefinition> restParameters ; // Autres parametres pour faciliter la récursion
non terminal ParameterDefinition parameter ; // parametre
non terminal ParameterDefinition normalParameter ; // parametre normal
non terminal ParameterDefinition refParameter ; // parametre de référence

non terminal Expression proc_body ;
// variablenliste
non terminal List<VariableExpression> variablenDefinitionList ;
non terminal VariableExpression variableDefinition ;
// appelle de procedures
non terminal Expression procedure_call ;
// arguments des procedures
non terminal List<Expression> arguments ;
non terminal List<Expression>  otherarguments;
non terminal List<Expression> argument ;
non terminal List<Expression> array_expressions ;
non terminal Expression atom ;
start with program ;


//program ::= PROC IDENT LPAREN  RPAREN LCURL RCURL; //TODO (assignment 2 and 3): Just a dummy, needs to be replaced by the actual spl grammar.

program ::= globaleDefintionList ;

// Type definition fonktioniert schon


globaleDefintionList ::= globaleDefinition
                     | globaleDefintionList globaleDefinition;

globaleDefinition ::= procedure| typeDefinition ;
 // Beispiele:
 // type myInt = int;
 // type intArray = array [10] of in

typeDefinition ::= TYPE IDENT EQ type SEMIC;

type ::= IDENT
       | ARRAY LBRACK INTLIT RBRACK OF type;

// procedure
procedure::= PROC IDENT LPAREN parameterList  RPAREN  LCURL proc_body RCURL;

//paramtres
parameterList ::= /* vide */ | nonEmptyParameterList; // pas vide
nonEmptyParameterList ::= parameter restParameters; // il peux etre le reste
parameter ::= normalParameter | refParameter; // le parametre est normal ou de reférence
normalParameter ::= IDENT COLON IDENT;  // Nom du paramètre suivi du type
refParameter ::= REF IDENT COLON IDENT;  // Paramètre passé par référence
restParameters ::= /* vide */ | COMMA nonEmptyParameterList;  // liste récursive des autres paramètres

// corpds de la méthode
proc_body ::= variablenDefinitionList statement_list ;

// Variable marche
variablenDefinitionList ::= /**/| variableDefinition variablenDefinitionList ;
variableDefinition ::=  VAR IDENT COLON IDENT SEMIC | VAR IDENT COLON ARRAY LBRACK INTLIT RBRACK OF type SEMIC;  // non terminal

// appel dde procedures
procedure_call ::= IDENT LPAREN arguments RPAREN SEMIC  ;
arguments::= /**/| argument ; // arguments
argument ::=   expression otherarguments   ;
otherarguments ::= /***/  | COMMA  argument;

//printExpressions::=/**/| printExpression printExpressions ;
//printExpression ::= /**/| INTLIT printExpressions ;

// a := b + c  sur plusieures lignes marchent
statement_list ::= /* epsilon */
                 | statement statement_list;

statement ::= assign_statement
            | whileStatement
            | ifStatement
            | compound_statement
            | procedure_call;

compound_statement ::= LCURL statement_list RCURL;

assign_statement ::= IDENT array_expressions ASGN expression SEMIC;

 conditional_expression ::= conditional_expression LT expression
                      |conditional_expression EQ expression
                      |conditional_expression  LE expression
                       |conditional_expression GT expression
                       |conditional_expression  GE expression
                       |conditional_expression  NE  expression;


expression ::= expression PLUS term
             | expression MINUS term
             | term;

term ::= term STAR factor |
       | term SLASH factor
       | factor;
factor::= atom ;

atom ::= LPAREN conditional_expression RPAREN
         | IDENT array_expressions
         | INTLIT
         |MINUS atom;

array_expressions ::= /* */ | array_expression array_expressions  ;
array_expression ::=  LBRACK expression RBRACK;

// while und while statement

whileStatement ::= WHILE LPAREN conditional_expression RPAREN statement ;

 // if Schleife
 // if (x < 0) x := 42;
 // if (x < 0) x := 42; else x := 43;
// Ca marche pour une seule ligne

ifStatement ::= IF LPAREN conditional_expression RPAREN statement |
IF LPAREN conditional_expression RPAREN statement ELSE statement;


